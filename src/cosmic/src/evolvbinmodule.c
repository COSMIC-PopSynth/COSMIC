/* File: evolvbinmodule.c
 * This file is auto-generated with f2py (version:1.23.4).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Tue Mar 28 20:54:51 2023
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif /* PY_SSIZE_T_CLEAN */

/* Unconditionally included */
#include <Python.h>
#include <numpy/npy_os.h>

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include <stdarg.h>
#include "fortranobject.h"
/*need_includes0*/

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *evolvbin_error;
static PyObject *evolvbin_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
/*need_typedefs*/

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif

#define rank(var) var ## _Rank
#define shape(var,dim) var ## _Dims[dim]
#define old_rank(var) (PyArray_NDIM((PyArrayObject *)(capi_ ## var ## _tmp)))
#define old_shape(var,dim) PyArray_DIM(((PyArrayObject *)(capi_ ## var ## _tmp)),dim)
#define fshape(var,dim) shape(var,rank(var)-dim-1)
#define len(var) shape(var,0)
#define flen(var) fshape(var,0)
#define old_size(var) PyArray_SIZE((PyArrayObject *)(capi_ ## var ## _tmp))
/* #define index(i) capi_i ## i */
#define slen(var) capi_ ## var ## _len
#define size(var, ...) f2py_size((PyArrayObject *)(capi_ ## var ## _tmp), ## __VA_ARGS__, -1)

#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
static int f2py_size(PyArrayObject* var, ...)
{
  npy_int sz = 0;
  npy_int dim;
  npy_int rank;
  va_list argp;
  va_start(argp, var);
  dim = va_arg(argp, npy_int);
  if (dim==-1)
    {
      sz = PyArray_SIZE(var);
    }
  else
    {
      rank = PyArray_NDIM(var);
      if (dim>=1 && dim<=rank)
        sz = PyArray_DIM(var, dim-1);
      else
        fprintf(stderr, "f2py_size: 2nd argument value=%d fails to satisfy 1<=value<=%d. Result will be 0.\n", dim, rank);
    }
  va_end(argp);
  return sz;
}

static int
double_from_pyobj(double* v, PyObject *obj, const char *errmess)
{
    PyObject* tmp = NULL;
    if (PyFloat_Check(obj)) {
        *v = PyFloat_AsDouble(obj);
        return !(*v == -1.0 && PyErr_Occurred());
    }

    tmp = PyNumber_Float(obj);
    if (tmp) {
        *v = PyFloat_AsDouble(tmp);
        Py_DECREF(tmp);
        return !(*v == -1.0 && PyErr_Occurred());
    }

    if (PyComplex_Check(obj)) {
        PyErr_Clear();
        tmp = PyObject_GetAttrString(obj,"real");
    }
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj)) {
        /*pass*/;
    }
    else if (PySequence_Check(obj)) {
        PyErr_Clear();
        tmp = PySequence_GetItem(obj, 0);
    }

    if (tmp) {
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = evolvbin_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
extern void F_FUNC(evolv2,EVOLV2)(int*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,int*,int*,double*);
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/*********************************** evolv2 ***********************************/
static char doc_f2py_rout_evolvbin_evolv2[] = "\
bpp_index_out,bcm_index_out,kick_info_out = evolv2(kstar,mass,tb,ecc,z,tphysf,dtp,mass0,rad,lumin,massc,radc,menv,renv,ospin,b_0,bacc,tacc,epoch,tms,bhspin,tphys,zpars,bkick,kick_info)\n\nWrapper for ``evolv2``.\
\n\nParameters\n----------\n"
"kstar : input rank-1 array('i') with bounds (2)\n"
"mass : input rank-1 array('d') with bounds (2)\n"
"tb : input float\n"
"ecc : input float\n"
"z : input float\n"
"tphysf : input float\n"
"dtp : input float\n"
"mass0 : input rank-1 array('d') with bounds (2)\n"
"rad : input rank-1 array('d') with bounds (2)\n"
"lumin : input rank-1 array('d') with bounds (2)\n"
"massc : input rank-1 array('d') with bounds (2)\n"
"radc : input rank-1 array('d') with bounds (2)\n"
"menv : input rank-1 array('d') with bounds (2)\n"
"renv : input rank-1 array('d') with bounds (2)\n"
"ospin : input rank-1 array('d') with bounds (2)\n"
"b_0 : input rank-1 array('d') with bounds (2)\n"
"bacc : input rank-1 array('d') with bounds (2)\n"
"tacc : input rank-1 array('d') with bounds (2)\n"
"epoch : input rank-1 array('d') with bounds (2)\n"
"tms : input rank-1 array('d') with bounds (2)\n"
"bhspin : input rank-1 array('d') with bounds (2)\n"
"tphys : input float\n"
"zpars : input rank-1 array('d') with bounds (20)\n"
"bkick : input rank-1 array('d') with bounds (20)\n"
"kick_info : input rank-2 array('d') with bounds (2,17)\n"
"\nReturns\n-------\n"
"bpp_index_out : int\n"
"bcm_index_out : int\n"
"kick_info_out : rank-2 array('d') with bounds (2,17)";
/* extern void F_FUNC(evolv2,EVOLV2)(int*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,int*,int*,double*); */
static PyObject *f2py_rout_evolvbin_evolv2(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,int*,int*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    int *kstar = NULL;
    npy_intp kstar_Dims[1] = {-1};
    const int kstar_Rank = 1;
    PyArrayObject *capi_kstar_tmp = NULL;
    int capi_kstar_intent = 0;
    PyObject *kstar_capi = Py_None;
    double *mass = NULL;
    npy_intp mass_Dims[1] = {-1};
    const int mass_Rank = 1;
    PyArrayObject *capi_mass_tmp = NULL;
    int capi_mass_intent = 0;
    PyObject *mass_capi = Py_None;
    double tb = 0;
    PyObject *tb_capi = Py_None;
    double ecc = 0;
    PyObject *ecc_capi = Py_None;
    double z = 0;
    PyObject *z_capi = Py_None;
    double tphysf = 0;
    PyObject *tphysf_capi = Py_None;
    double dtp = 0;
    PyObject *dtp_capi = Py_None;
    double *mass0 = NULL;
    npy_intp mass0_Dims[1] = {-1};
    const int mass0_Rank = 1;
    PyArrayObject *capi_mass0_tmp = NULL;
    int capi_mass0_intent = 0;
    PyObject *mass0_capi = Py_None;
    double *rad = NULL;
    npy_intp rad_Dims[1] = {-1};
    const int rad_Rank = 1;
    PyArrayObject *capi_rad_tmp = NULL;
    int capi_rad_intent = 0;
    PyObject *rad_capi = Py_None;
    double *lumin = NULL;
    npy_intp lumin_Dims[1] = {-1};
    const int lumin_Rank = 1;
    PyArrayObject *capi_lumin_tmp = NULL;
    int capi_lumin_intent = 0;
    PyObject *lumin_capi = Py_None;
    double *massc = NULL;
    npy_intp massc_Dims[1] = {-1};
    const int massc_Rank = 1;
    PyArrayObject *capi_massc_tmp = NULL;
    int capi_massc_intent = 0;
    PyObject *massc_capi = Py_None;
    double *radc = NULL;
    npy_intp radc_Dims[1] = {-1};
    const int radc_Rank = 1;
    PyArrayObject *capi_radc_tmp = NULL;
    int capi_radc_intent = 0;
    PyObject *radc_capi = Py_None;
    double *menv = NULL;
    npy_intp menv_Dims[1] = {-1};
    const int menv_Rank = 1;
    PyArrayObject *capi_menv_tmp = NULL;
    int capi_menv_intent = 0;
    PyObject *menv_capi = Py_None;
    double *renv = NULL;
    npy_intp renv_Dims[1] = {-1};
    const int renv_Rank = 1;
    PyArrayObject *capi_renv_tmp = NULL;
    int capi_renv_intent = 0;
    PyObject *renv_capi = Py_None;
    double *ospin = NULL;
    npy_intp ospin_Dims[1] = {-1};
    const int ospin_Rank = 1;
    PyArrayObject *capi_ospin_tmp = NULL;
    int capi_ospin_intent = 0;
    PyObject *ospin_capi = Py_None;
    double *b_0 = NULL;
    npy_intp b_0_Dims[1] = {-1};
    const int b_0_Rank = 1;
    PyArrayObject *capi_b_0_tmp = NULL;
    int capi_b_0_intent = 0;
    PyObject *b_0_capi = Py_None;
    double *bacc = NULL;
    npy_intp bacc_Dims[1] = {-1};
    const int bacc_Rank = 1;
    PyArrayObject *capi_bacc_tmp = NULL;
    int capi_bacc_intent = 0;
    PyObject *bacc_capi = Py_None;
    double *tacc = NULL;
    npy_intp tacc_Dims[1] = {-1};
    const int tacc_Rank = 1;
    PyArrayObject *capi_tacc_tmp = NULL;
    int capi_tacc_intent = 0;
    PyObject *tacc_capi = Py_None;
    double *epoch = NULL;
    npy_intp epoch_Dims[1] = {-1};
    const int epoch_Rank = 1;
    PyArrayObject *capi_epoch_tmp = NULL;
    int capi_epoch_intent = 0;
    PyObject *epoch_capi = Py_None;
    double *tms = NULL;
    npy_intp tms_Dims[1] = {-1};
    const int tms_Rank = 1;
    PyArrayObject *capi_tms_tmp = NULL;
    int capi_tms_intent = 0;
    PyObject *tms_capi = Py_None;
    double *bhspin = NULL;
    npy_intp bhspin_Dims[1] = {-1};
    const int bhspin_Rank = 1;
    PyArrayObject *capi_bhspin_tmp = NULL;
    int capi_bhspin_intent = 0;
    PyObject *bhspin_capi = Py_None;
    double tphys = 0;
    PyObject *tphys_capi = Py_None;
    double *zpars = NULL;
    npy_intp zpars_Dims[1] = {-1};
    const int zpars_Rank = 1;
    PyArrayObject *capi_zpars_tmp = NULL;
    int capi_zpars_intent = 0;
    PyObject *zpars_capi = Py_None;
    double *bkick = NULL;
    npy_intp bkick_Dims[1] = {-1};
    const int bkick_Rank = 1;
    PyArrayObject *capi_bkick_tmp = NULL;
    int capi_bkick_intent = 0;
    PyObject *bkick_capi = Py_None;
    double *kick_info = NULL;
    npy_intp kick_info_Dims[2] = {-1, -1};
    const int kick_info_Rank = 2;
    PyArrayObject *capi_kick_info_tmp = NULL;
    int capi_kick_info_intent = 0;
    PyObject *kick_info_capi = Py_None;
    int bpp_index_out = 0;
    int bcm_index_out = 0;
    double *kick_info_out = NULL;
    npy_intp kick_info_out_Dims[2] = {-1, -1};
    const int kick_info_out_Rank = 2;
    PyArrayObject *capi_kick_info_out_tmp = NULL;
    int capi_kick_info_out_intent = 0;
    static char *capi_kwlist[] = {"kstar","mass","tb","ecc","z","tphysf","dtp","mass0","rad","lumin","massc","radc","menv","renv","ospin","b_0","bacc","tacc","epoch","tms","bhspin","tphys","zpars","bkick","kick_info",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOOOOOOOOOOOOOOOOOOOOOO|:evolvbin.evolv2",\
        capi_kwlist,&kstar_capi,&mass_capi,&tb_capi,&ecc_capi,&z_capi,&tphysf_capi,&dtp_capi,&mass0_capi,&rad_capi,&lumin_capi,&massc_capi,&radc_capi,&menv_capi,&renv_capi,&ospin_capi,&b_0_capi,&bacc_capi,&tacc_capi,&epoch_capi,&tms_capi,&bhspin_capi,&tphys_capi,&zpars_capi,&bkick_capi,&kick_info_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable bcm_index_out */
    /* Processing variable bpp_index_out */
    /* Processing variable kstar */
    kstar_Dims[0]=2;
    capi_kstar_intent |= F2PY_INTENT_IN;
    capi_kstar_tmp = array_from_pyobj(NPY_INT,kstar_Dims,kstar_Rank,capi_kstar_intent,kstar_capi);
    if (capi_kstar_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 1st argument `kstar' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        kstar = (int *)(PyArray_DATA(capi_kstar_tmp));

    /* Processing variable tphys */
        f2py_success = double_from_pyobj(&tphys,tphys_capi,"evolvbin.evolv2() 22nd argument (tphys) can't be converted to double");
    if (f2py_success) {
    /* Processing variable tphysf */
        f2py_success = double_from_pyobj(&tphysf,tphysf_capi,"evolvbin.evolv2() 6th argument (tphysf) can't be converted to double");
    if (f2py_success) {
    /* Processing variable dtp */
        f2py_success = double_from_pyobj(&dtp,dtp_capi,"evolvbin.evolv2() 7th argument (dtp) can't be converted to double");
    if (f2py_success) {
    /* Processing variable epoch */
    epoch_Dims[0]=2;
    capi_epoch_intent |= F2PY_INTENT_IN;
    capi_epoch_tmp = array_from_pyobj(NPY_DOUBLE,epoch_Dims,epoch_Rank,capi_epoch_intent,epoch_capi);
    if (capi_epoch_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 19th argument `epoch' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        epoch = (double *)(PyArray_DATA(capi_epoch_tmp));

    /* Processing variable tms */
    tms_Dims[0]=2;
    capi_tms_intent |= F2PY_INTENT_IN;
    capi_tms_tmp = array_from_pyobj(NPY_DOUBLE,tms_Dims,tms_Rank,capi_tms_intent,tms_capi);
    if (capi_tms_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 20th argument `tms' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        tms = (double *)(PyArray_DATA(capi_tms_tmp));

    /* Processing variable mass0 */
    mass0_Dims[0]=2;
    capi_mass0_intent |= F2PY_INTENT_IN;
    capi_mass0_tmp = array_from_pyobj(NPY_DOUBLE,mass0_Dims,mass0_Rank,capi_mass0_intent,mass0_capi);
    if (capi_mass0_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 8th argument `mass0' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        mass0 = (double *)(PyArray_DATA(capi_mass0_tmp));

    /* Processing variable mass */
    mass_Dims[0]=2;
    capi_mass_intent |= F2PY_INTENT_IN;
    capi_mass_tmp = array_from_pyobj(NPY_DOUBLE,mass_Dims,mass_Rank,capi_mass_intent,mass_capi);
    if (capi_mass_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 2nd argument `mass' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        mass = (double *)(PyArray_DATA(capi_mass_tmp));

    /* Processing variable massc */
    massc_Dims[0]=2;
    capi_massc_intent |= F2PY_INTENT_IN;
    capi_massc_tmp = array_from_pyobj(NPY_DOUBLE,massc_Dims,massc_Rank,capi_massc_intent,massc_capi);
    if (capi_massc_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 11st argument `massc' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        massc = (double *)(PyArray_DATA(capi_massc_tmp));

    /* Processing variable menv */
    menv_Dims[0]=2;
    capi_menv_intent |= F2PY_INTENT_IN;
    capi_menv_tmp = array_from_pyobj(NPY_DOUBLE,menv_Dims,menv_Rank,capi_menv_intent,menv_capi);
    if (capi_menv_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 13rd argument `menv' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        menv = (double *)(PyArray_DATA(capi_menv_tmp));

    /* Processing variable rad */
    rad_Dims[0]=2;
    capi_rad_intent |= F2PY_INTENT_IN;
    capi_rad_tmp = array_from_pyobj(NPY_DOUBLE,rad_Dims,rad_Rank,capi_rad_intent,rad_capi);
    if (capi_rad_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 9th argument `rad' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        rad = (double *)(PyArray_DATA(capi_rad_tmp));

    /* Processing variable radc */
    radc_Dims[0]=2;
    capi_radc_intent |= F2PY_INTENT_IN;
    capi_radc_tmp = array_from_pyobj(NPY_DOUBLE,radc_Dims,radc_Rank,capi_radc_intent,radc_capi);
    if (capi_radc_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 12nd argument `radc' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        radc = (double *)(PyArray_DATA(capi_radc_tmp));

    /* Processing variable renv */
    renv_Dims[0]=2;
    capi_renv_intent |= F2PY_INTENT_IN;
    capi_renv_tmp = array_from_pyobj(NPY_DOUBLE,renv_Dims,renv_Rank,capi_renv_intent,renv_capi);
    if (capi_renv_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 14th argument `renv' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        renv = (double *)(PyArray_DATA(capi_renv_tmp));

    /* Processing variable lumin */
    lumin_Dims[0]=2;
    capi_lumin_intent |= F2PY_INTENT_IN;
    capi_lumin_tmp = array_from_pyobj(NPY_DOUBLE,lumin_Dims,lumin_Rank,capi_lumin_intent,lumin_capi);
    if (capi_lumin_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 10th argument `lumin' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        lumin = (double *)(PyArray_DATA(capi_lumin_tmp));

    /* Processing variable kick_info */
    kick_info_Dims[0]=2,kick_info_Dims[1]=17;
    capi_kick_info_intent |= F2PY_INTENT_IN;
    capi_kick_info_tmp = array_from_pyobj(NPY_DOUBLE,kick_info_Dims,kick_info_Rank,capi_kick_info_intent,kick_info_capi);
    if (capi_kick_info_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 25th argument `kick_info' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        kick_info = (double *)(PyArray_DATA(capi_kick_info_tmp));

    /* Processing variable bkick */
    bkick_Dims[0]=20;
    capi_bkick_intent |= F2PY_INTENT_IN;
    capi_bkick_tmp = array_from_pyobj(NPY_DOUBLE,bkick_Dims,bkick_Rank,capi_bkick_intent,bkick_capi);
    if (capi_bkick_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 24th argument `bkick' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        bkick = (double *)(PyArray_DATA(capi_bkick_tmp));

    /* Processing variable kick_info_out */
    kick_info_out_Dims[0]=2,kick_info_out_Dims[1]=17;
    capi_kick_info_out_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    capi_kick_info_out_tmp = array_from_pyobj(NPY_DOUBLE,kick_info_out_Dims,kick_info_out_Rank,capi_kick_info_out_intent,Py_None);
    if (capi_kick_info_out_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting hidden `kick_info_out' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        kick_info_out = (double *)(PyArray_DATA(capi_kick_info_out_tmp));

    /* Processing variable tb */
        f2py_success = double_from_pyobj(&tb,tb_capi,"evolvbin.evolv2() 3rd argument (tb) can't be converted to double");
    if (f2py_success) {
    /* Processing variable ecc */
        f2py_success = double_from_pyobj(&ecc,ecc_capi,"evolvbin.evolv2() 4th argument (ecc) can't be converted to double");
    if (f2py_success) {
    /* Processing variable ospin */
    ospin_Dims[0]=2;
    capi_ospin_intent |= F2PY_INTENT_IN;
    capi_ospin_tmp = array_from_pyobj(NPY_DOUBLE,ospin_Dims,ospin_Rank,capi_ospin_intent,ospin_capi);
    if (capi_ospin_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 15th argument `ospin' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        ospin = (double *)(PyArray_DATA(capi_ospin_tmp));

    /* Processing variable bhspin */
    bhspin_Dims[0]=2;
    capi_bhspin_intent |= F2PY_INTENT_IN;
    capi_bhspin_tmp = array_from_pyobj(NPY_DOUBLE,bhspin_Dims,bhspin_Rank,capi_bhspin_intent,bhspin_capi);
    if (capi_bhspin_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 21st argument `bhspin' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        bhspin = (double *)(PyArray_DATA(capi_bhspin_tmp));

    /* Processing variable b_0 */
    b_0_Dims[0]=2;
    capi_b_0_intent |= F2PY_INTENT_IN;
    capi_b_0_tmp = array_from_pyobj(NPY_DOUBLE,b_0_Dims,b_0_Rank,capi_b_0_intent,b_0_capi);
    if (capi_b_0_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 16th argument `b_0' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        b_0 = (double *)(PyArray_DATA(capi_b_0_tmp));

    /* Processing variable bacc */
    bacc_Dims[0]=2;
    capi_bacc_intent |= F2PY_INTENT_IN;
    capi_bacc_tmp = array_from_pyobj(NPY_DOUBLE,bacc_Dims,bacc_Rank,capi_bacc_intent,bacc_capi);
    if (capi_bacc_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 17th argument `bacc' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        bacc = (double *)(PyArray_DATA(capi_bacc_tmp));

    /* Processing variable tacc */
    tacc_Dims[0]=2;
    capi_tacc_intent |= F2PY_INTENT_IN;
    capi_tacc_tmp = array_from_pyobj(NPY_DOUBLE,tacc_Dims,tacc_Rank,capi_tacc_intent,tacc_capi);
    if (capi_tacc_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 18th argument `tacc' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        tacc = (double *)(PyArray_DATA(capi_tacc_tmp));

    /* Processing variable z */
        f2py_success = double_from_pyobj(&z,z_capi,"evolvbin.evolv2() 5th argument (z) can't be converted to double");
    if (f2py_success) {
    /* Processing variable zpars */
    zpars_Dims[0]=20;
    capi_zpars_intent |= F2PY_INTENT_IN;
    capi_zpars_tmp = array_from_pyobj(NPY_DOUBLE,zpars_Dims,zpars_Rank,capi_zpars_intent,zpars_capi);
    if (capi_zpars_tmp == NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_SetString(exc ? exc : evolvbin_error,"failed in converting 23rd argument `zpars' of evolvbin.evolv2 to C/Fortran array" );
        npy_PyErr_ChainExceptionsCause(exc, val, tb);
    } else {
        zpars = (double *)(PyArray_DATA(capi_zpars_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
                (*f2py_func)(kstar,mass,&tb,&ecc,&z,&tphysf,&dtp,mass0,rad,lumin,massc,radc,menv,renv,ospin,b_0,bacc,tacc,epoch,tms,bhspin,&tphys,zpars,bkick,kick_info,&bpp_index_out,&bcm_index_out,kick_info_out);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("iiN",bpp_index_out,bcm_index_out,capi_kick_info_out_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    if((PyObject *)capi_zpars_tmp!=zpars_capi) {
        Py_XDECREF(capi_zpars_tmp); }
    }  /*if (capi_zpars_tmp == NULL) ... else of zpars*/
    /* End of cleaning variable zpars */
    } /*if (f2py_success) of z*/
    /* End of cleaning variable z */
    if((PyObject *)capi_tacc_tmp!=tacc_capi) {
        Py_XDECREF(capi_tacc_tmp); }
    }  /*if (capi_tacc_tmp == NULL) ... else of tacc*/
    /* End of cleaning variable tacc */
    if((PyObject *)capi_bacc_tmp!=bacc_capi) {
        Py_XDECREF(capi_bacc_tmp); }
    }  /*if (capi_bacc_tmp == NULL) ... else of bacc*/
    /* End of cleaning variable bacc */
    if((PyObject *)capi_b_0_tmp!=b_0_capi) {
        Py_XDECREF(capi_b_0_tmp); }
    }  /*if (capi_b_0_tmp == NULL) ... else of b_0*/
    /* End of cleaning variable b_0 */
    if((PyObject *)capi_bhspin_tmp!=bhspin_capi) {
        Py_XDECREF(capi_bhspin_tmp); }
    }  /*if (capi_bhspin_tmp == NULL) ... else of bhspin*/
    /* End of cleaning variable bhspin */
    if((PyObject *)capi_ospin_tmp!=ospin_capi) {
        Py_XDECREF(capi_ospin_tmp); }
    }  /*if (capi_ospin_tmp == NULL) ... else of ospin*/
    /* End of cleaning variable ospin */
    } /*if (f2py_success) of ecc*/
    /* End of cleaning variable ecc */
    } /*if (f2py_success) of tb*/
    /* End of cleaning variable tb */
    }  /*if (capi_kick_info_out_tmp == NULL) ... else of kick_info_out*/
    /* End of cleaning variable kick_info_out */
    if((PyObject *)capi_bkick_tmp!=bkick_capi) {
        Py_XDECREF(capi_bkick_tmp); }
    }  /*if (capi_bkick_tmp == NULL) ... else of bkick*/
    /* End of cleaning variable bkick */
    if((PyObject *)capi_kick_info_tmp!=kick_info_capi) {
        Py_XDECREF(capi_kick_info_tmp); }
    }  /*if (capi_kick_info_tmp == NULL) ... else of kick_info*/
    /* End of cleaning variable kick_info */
    if((PyObject *)capi_lumin_tmp!=lumin_capi) {
        Py_XDECREF(capi_lumin_tmp); }
    }  /*if (capi_lumin_tmp == NULL) ... else of lumin*/
    /* End of cleaning variable lumin */
    if((PyObject *)capi_renv_tmp!=renv_capi) {
        Py_XDECREF(capi_renv_tmp); }
    }  /*if (capi_renv_tmp == NULL) ... else of renv*/
    /* End of cleaning variable renv */
    if((PyObject *)capi_radc_tmp!=radc_capi) {
        Py_XDECREF(capi_radc_tmp); }
    }  /*if (capi_radc_tmp == NULL) ... else of radc*/
    /* End of cleaning variable radc */
    if((PyObject *)capi_rad_tmp!=rad_capi) {
        Py_XDECREF(capi_rad_tmp); }
    }  /*if (capi_rad_tmp == NULL) ... else of rad*/
    /* End of cleaning variable rad */
    if((PyObject *)capi_menv_tmp!=menv_capi) {
        Py_XDECREF(capi_menv_tmp); }
    }  /*if (capi_menv_tmp == NULL) ... else of menv*/
    /* End of cleaning variable menv */
    if((PyObject *)capi_massc_tmp!=massc_capi) {
        Py_XDECREF(capi_massc_tmp); }
    }  /*if (capi_massc_tmp == NULL) ... else of massc*/
    /* End of cleaning variable massc */
    if((PyObject *)capi_mass_tmp!=mass_capi) {
        Py_XDECREF(capi_mass_tmp); }
    }  /*if (capi_mass_tmp == NULL) ... else of mass*/
    /* End of cleaning variable mass */
    if((PyObject *)capi_mass0_tmp!=mass0_capi) {
        Py_XDECREF(capi_mass0_tmp); }
    }  /*if (capi_mass0_tmp == NULL) ... else of mass0*/
    /* End of cleaning variable mass0 */
    if((PyObject *)capi_tms_tmp!=tms_capi) {
        Py_XDECREF(capi_tms_tmp); }
    }  /*if (capi_tms_tmp == NULL) ... else of tms*/
    /* End of cleaning variable tms */
    if((PyObject *)capi_epoch_tmp!=epoch_capi) {
        Py_XDECREF(capi_epoch_tmp); }
    }  /*if (capi_epoch_tmp == NULL) ... else of epoch*/
    /* End of cleaning variable epoch */
    } /*if (f2py_success) of dtp*/
    /* End of cleaning variable dtp */
    } /*if (f2py_success) of tphysf*/
    /* End of cleaning variable tphysf */
    } /*if (f2py_success) of tphys*/
    /* End of cleaning variable tphys */
    if((PyObject *)capi_kstar_tmp!=kstar_capi) {
        Py_XDECREF(capi_kstar_tmp); }
    }  /*if (capi_kstar_tmp == NULL) ... else of kstar*/
    /* End of cleaning variable kstar */
    /* End of cleaning variable bpp_index_out */
    /* End of cleaning variable bcm_index_out */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of evolv2 *******************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/
/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

static FortranDataDef f2py_rand1_def[] = {
  {"idum1",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_rand1(char *idum1) {
  int i_f2py=0;
  f2py_rand1_def[i_f2py++].data = idum1;
}
extern void F_FUNC(f2pyinitrand1,F2PYINITRAND1)(void(*)(char*));
static void f2py_init_rand1(void) {
  F_FUNC(f2pyinitrand1,F2PYINITRAND1)(f2py_setup_rand1);
}

static FortranDataDef f2py_rand2_def[] = {
  {"idum2",0,{{-1}},NPY_INT},
  {"iy",0,{{-1}},NPY_INT},
  {"ir",1,{{32}},NPY_INT},
  {NULL}
};
static void f2py_setup_rand2(char *idum2,char *iy,char *ir) {
  int i_f2py=0;
  f2py_rand2_def[i_f2py++].data = idum2;
  f2py_rand2_def[i_f2py++].data = iy;
  f2py_rand2_def[i_f2py++].data = ir;
}
extern void F_FUNC(f2pyinitrand2,F2PYINITRAND2)(void(*)(char*,char*,char*));
static void f2py_init_rand2(void) {
  F_FUNC(f2pyinitrand2,F2PYINITRAND2)(f2py_setup_rand2);
}

static FortranDataDef f2py_types_def[] = {
  {"ktype",2,{{15,15}},NPY_INT},
  {NULL}
};
static void f2py_setup_types(char *ktype) {
  int i_f2py=0;
  f2py_types_def[i_f2py++].data = ktype;
}
extern void F_FUNC(f2pyinittypes,F2PYINITTYPES)(void(*)(char*));
static void f2py_init_types(void) {
  F_FUNC(f2pyinittypes,F2PYINITTYPES)(f2py_setup_types);
}

static FortranDataDef f2py_flags_def[] = {
  {"tflag",0,{{-1}},NPY_INT},
  {"ifflag",0,{{-1}},NPY_INT},
  {"remnantflag",0,{{-1}},NPY_INT},
  {"wdflag",0,{{-1}},NPY_INT},
  {"bhflag",0,{{-1}},NPY_INT},
  {"windflag",0,{{-1}},NPY_INT},
  {"qcflag",0,{{-1}},NPY_INT},
  {"eddlimflag",0,{{-1}},NPY_INT},
  {"bhspinflag",0,{{-1}},NPY_INT},
  {"aic",0,{{-1}},NPY_INT},
  {"rejuvflag",0,{{-1}},NPY_INT},
  {"htpmb",0,{{-1}},NPY_INT},
  {"st_cr",0,{{-1}},NPY_INT},
  {"st_tide",0,{{-1}},NPY_INT},
  {"bdecayfac",0,{{-1}},NPY_INT},
  {"grflag",0,{{-1}},NPY_INT},
  {"bhms_coll_flag",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_flags(char *tflag,char *ifflag,char *remnantflag,char *wdflag,char *bhflag,char *windflag,char *qcflag,char *eddlimflag,char *bhspinflag,char *aic,char *rejuvflag,char *htpmb,char *st_cr,char *st_tide,char *bdecayfac,char *grflag,char *bhms_coll_flag) {
  int i_f2py=0;
  f2py_flags_def[i_f2py++].data = tflag;
  f2py_flags_def[i_f2py++].data = ifflag;
  f2py_flags_def[i_f2py++].data = remnantflag;
  f2py_flags_def[i_f2py++].data = wdflag;
  f2py_flags_def[i_f2py++].data = bhflag;
  f2py_flags_def[i_f2py++].data = windflag;
  f2py_flags_def[i_f2py++].data = qcflag;
  f2py_flags_def[i_f2py++].data = eddlimflag;
  f2py_flags_def[i_f2py++].data = bhspinflag;
  f2py_flags_def[i_f2py++].data = aic;
  f2py_flags_def[i_f2py++].data = rejuvflag;
  f2py_flags_def[i_f2py++].data = htpmb;
  f2py_flags_def[i_f2py++].data = st_cr;
  f2py_flags_def[i_f2py++].data = st_tide;
  f2py_flags_def[i_f2py++].data = bdecayfac;
  f2py_flags_def[i_f2py++].data = grflag;
  f2py_flags_def[i_f2py++].data = bhms_coll_flag;
}
extern void F_FUNC(f2pyinitflags,F2PYINITFLAGS)(void(*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_flags(void) {
  F_FUNC(f2pyinitflags,F2PYINITFLAGS)(f2py_setup_flags);
}

static FortranDataDef f2py_mtvars_def[] = {
  {"don_lim",0,{{-1}},NPY_DOUBLE},
  {"acc_lim",0,{{-1}},NPY_DOUBLE},
  {"mbh_initial",0,{{-1}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_mtvars(char *don_lim,char *acc_lim,char *mbh_initial) {
  int i_f2py=0;
  f2py_mtvars_def[i_f2py++].data = don_lim;
  f2py_mtvars_def[i_f2py++].data = acc_lim;
  f2py_mtvars_def[i_f2py++].data = mbh_initial;
}
extern void F_FUNC(f2pyinitmtvars,F2PYINITMTVARS)(void(*)(char*,char*,char*));
static void f2py_init_mtvars(void) {
  F_FUNC(f2pyinitmtvars,F2PYINITMTVARS)(f2py_setup_mtvars);
}

static FortranDataDef f2py_ceflags_def[] = {
  {"ceflag",0,{{-1}},NPY_INT},
  {"cekickflag",0,{{-1}},NPY_INT},
  {"cemergeflag",0,{{-1}},NPY_INT},
  {"cehestarflag",0,{{-1}},NPY_INT},
  {"ussn",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_ceflags(char *ceflag,char *cekickflag,char *cemergeflag,char *cehestarflag,char *ussn) {
  int i_f2py=0;
  f2py_ceflags_def[i_f2py++].data = ceflag;
  f2py_ceflags_def[i_f2py++].data = cekickflag;
  f2py_ceflags_def[i_f2py++].data = cemergeflag;
  f2py_ceflags_def[i_f2py++].data = cehestarflag;
  f2py_ceflags_def[i_f2py++].data = ussn;
}
extern void F_FUNC(f2pyinitceflags,F2PYINITCEFLAGS)(void(*)(char*,char*,char*,char*,char*));
static void f2py_init_ceflags(void) {
  F_FUNC(f2pyinitceflags,F2PYINITCEFLAGS)(f2py_setup_ceflags);
}

static FortranDataDef f2py_trackers_def[] = {
  {"pisn_track",1,{{2}},NPY_INT},
  {NULL}
};
static void f2py_setup_trackers(char *pisn_track) {
  int i_f2py=0;
  f2py_trackers_def[i_f2py++].data = pisn_track;
}
extern void F_FUNC(f2pyinittrackers,F2PYINITTRACKERS)(void(*)(char*));
static void f2py_init_trackers(void) {
  F_FUNC(f2pyinittrackers,F2PYINITTRACKERS)(f2py_setup_trackers);
}

static FortranDataDef f2py_metvars_def[] = {
  {"zsun",0,{{-1}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_metvars(char *zsun) {
  int i_f2py=0;
  f2py_metvars_def[i_f2py++].data = zsun;
}
extern void F_FUNC(f2pyinitmetvars,F2PYINITMETVARS)(void(*)(char*));
static void f2py_init_metvars(void) {
  F_FUNC(f2pyinitmetvars,F2PYINITMETVARS)(f2py_setup_metvars);
}

static FortranDataDef f2py_windvars_def[] = {
  {"neta",0,{{-1}},NPY_DOUBLE},
  {"bwind",0,{{-1}},NPY_DOUBLE},
  {"hewind",0,{{-1}},NPY_DOUBLE},
  {"beta",0,{{-1}},NPY_DOUBLE},
  {"xi",0,{{-1}},NPY_DOUBLE},
  {"acc2",0,{{-1}},NPY_DOUBLE},
  {"epsnov",0,{{-1}},NPY_DOUBLE},
  {"eddfac",0,{{-1}},NPY_DOUBLE},
  {"gamma",0,{{-1}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_windvars(char *neta,char *bwind,char *hewind,char *beta,char *xi,char *acc2,char *epsnov,char *eddfac,char *gamma) {
  int i_f2py=0;
  f2py_windvars_def[i_f2py++].data = neta;
  f2py_windvars_def[i_f2py++].data = bwind;
  f2py_windvars_def[i_f2py++].data = hewind;
  f2py_windvars_def[i_f2py++].data = beta;
  f2py_windvars_def[i_f2py++].data = xi;
  f2py_windvars_def[i_f2py++].data = acc2;
  f2py_windvars_def[i_f2py++].data = epsnov;
  f2py_windvars_def[i_f2py++].data = eddfac;
  f2py_windvars_def[i_f2py++].data = gamma;
}
extern void F_FUNC(f2pyinitwindvars,F2PYINITWINDVARS)(void(*)(char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_windvars(void) {
  F_FUNC(f2pyinitwindvars,F2PYINITWINDVARS)(f2py_setup_windvars);
}

static FortranDataDef f2py_cevars_def[] = {
  {"qcrit_array",1,{{16}},NPY_DOUBLE},
  {"alpha1",0,{{-1}},NPY_DOUBLE},
  {"lambdaf",0,{{-1}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_cevars(char *qcrit_array,char *alpha1,char *lambdaf) {
  int i_f2py=0;
  f2py_cevars_def[i_f2py++].data = qcrit_array;
  f2py_cevars_def[i_f2py++].data = alpha1;
  f2py_cevars_def[i_f2py++].data = lambdaf;
}
extern void F_FUNC(f2pyinitcevars,F2PYINITCEVARS)(void(*)(char*,char*,char*));
static void f2py_init_cevars(void) {
  F_FUNC(f2pyinitcevars,F2PYINITCEVARS)(f2py_setup_cevars);
}

static FortranDataDef f2py_magvars_def[] = {
  {"bconst",0,{{-1}},NPY_DOUBLE},
  {"ck",0,{{-1}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_magvars(char *bconst,char *ck) {
  int i_f2py=0;
  f2py_magvars_def[i_f2py++].data = bconst;
  f2py_magvars_def[i_f2py++].data = ck;
}
extern void F_FUNC(f2pyinitmagvars,F2PYINITMAGVARS)(void(*)(char*,char*));
static void f2py_init_magvars(void) {
  F_FUNC(f2pyinitmagvars,F2PYINITMAGVARS)(f2py_setup_magvars);
}

static FortranDataDef f2py_snvars_def[] = {
  {"natal_kick_array",2,{{2,5}},NPY_DOUBLE},
  {"sigma",0,{{-1}},NPY_DOUBLE},
  {"sigmadiv",0,{{-1}},NPY_DOUBLE},
  {"bhsigmafrac",0,{{-1}},NPY_DOUBLE},
  {"polar_kick_angle",0,{{-1}},NPY_DOUBLE},
  {"pisn",0,{{-1}},NPY_DOUBLE},
  {"ecsn",0,{{-1}},NPY_DOUBLE},
  {"ecsn_mlow",0,{{-1}},NPY_DOUBLE},
  {"bhspinmag",0,{{-1}},NPY_DOUBLE},
  {"mxns",0,{{-1}},NPY_DOUBLE},
  {"rembar_massloss",0,{{-1}},NPY_DOUBLE},
  {"kickflag",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_snvars(char *natal_kick_array,char *sigma,char *sigmadiv,char *bhsigmafrac,char *polar_kick_angle,char *pisn,char *ecsn,char *ecsn_mlow,char *bhspinmag,char *mxns,char *rembar_massloss,char *kickflag) {
  int i_f2py=0;
  f2py_snvars_def[i_f2py++].data = natal_kick_array;
  f2py_snvars_def[i_f2py++].data = sigma;
  f2py_snvars_def[i_f2py++].data = sigmadiv;
  f2py_snvars_def[i_f2py++].data = bhsigmafrac;
  f2py_snvars_def[i_f2py++].data = polar_kick_angle;
  f2py_snvars_def[i_f2py++].data = pisn;
  f2py_snvars_def[i_f2py++].data = ecsn;
  f2py_snvars_def[i_f2py++].data = ecsn_mlow;
  f2py_snvars_def[i_f2py++].data = bhspinmag;
  f2py_snvars_def[i_f2py++].data = mxns;
  f2py_snvars_def[i_f2py++].data = rembar_massloss;
  f2py_snvars_def[i_f2py++].data = kickflag;
}
extern void F_FUNC(f2pyinitsnvars,F2PYINITSNVARS)(void(*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_snvars(void) {
  F_FUNC(f2pyinitsnvars,F2PYINITSNVARS)(f2py_setup_snvars);
}

static FortranDataDef f2py_tidalvars_def[] = {
  {"fprimc_array",1,{{16}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_tidalvars(char *fprimc_array) {
  int i_f2py=0;
  f2py_tidalvars_def[i_f2py++].data = fprimc_array;
}
extern void F_FUNC(f2pyinittidalvars,F2PYINITTIDALVARS)(void(*)(char*));
static void f2py_init_tidalvars(void) {
  F_FUNC(f2pyinittidalvars,F2PYINITTIDALVARS)(f2py_setup_tidalvars);
}

static FortranDataDef f2py_mixvars_def[] = {
  {"rejuv_fac",0,{{-1}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_mixvars(char *rejuv_fac) {
  int i_f2py=0;
  f2py_mixvars_def[i_f2py++].data = rejuv_fac;
}
extern void F_FUNC(f2pyinitmixvars,F2PYINITMIXVARS)(void(*)(char*));
static void f2py_init_mixvars(void) {
  F_FUNC(f2pyinitmixvars,F2PYINITMIXVARS)(f2py_setup_mixvars);
}

static FortranDataDef f2py_cmcpass_def[] = {
  {"merger",0,{{-1}},NPY_DOUBLE},
  {"id1_pass",0,{{-1}},NPY_LONGLONG},
  {"id2_pass",0,{{-1}},NPY_LONGLONG},
  {"using_cmc",0,{{-1}},NPY_LONGLONG},
  {NULL}
};
static void f2py_setup_cmcpass(char *merger,char *id1_pass,char *id2_pass,char *using_cmc) {
  int i_f2py=0;
  f2py_cmcpass_def[i_f2py++].data = merger;
  f2py_cmcpass_def[i_f2py++].data = id1_pass;
  f2py_cmcpass_def[i_f2py++].data = id2_pass;
  f2py_cmcpass_def[i_f2py++].data = using_cmc;
}
extern void F_FUNC(f2pyinitcmcpass,F2PYINITCMCPASS)(void(*)(char*,char*,char*,char*));
static void f2py_init_cmcpass(void) {
  F_FUNC(f2pyinitcmcpass,F2PYINITCMCPASS)(f2py_setup_cmcpass);
}

static FortranDataDef f2py_points_def[] = {
  {"pts1",0,{{-1}},NPY_DOUBLE},
  {"pts2",0,{{-1}},NPY_DOUBLE},
  {"pts3",0,{{-1}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_points(char *pts1,char *pts2,char *pts3) {
  int i_f2py=0;
  f2py_points_def[i_f2py++].data = pts1;
  f2py_points_def[i_f2py++].data = pts2;
  f2py_points_def[i_f2py++].data = pts3;
}
extern void F_FUNC(f2pyinitpoints,F2PYINITPOINTS)(void(*)(char*,char*,char*));
static void f2py_init_points(void) {
  F_FUNC(f2pyinitpoints,F2PYINITPOINTS)(f2py_setup_points);
}

static FortranDataDef f2py_tstepc_def[] = {
  {"dmmax",0,{{-1}},NPY_DOUBLE},
  {"drmax",0,{{-1}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_tstepc(char *dmmax,char *drmax) {
  int i_f2py=0;
  f2py_tstepc_def[i_f2py++].data = dmmax;
  f2py_tstepc_def[i_f2py++].data = drmax;
}
extern void F_FUNC(f2pyinittstepc,F2PYINITTSTEPC)(void(*)(char*,char*));
static void f2py_init_tstepc(void) {
  F_FUNC(f2pyinittstepc,F2PYINITTSTEPC)(f2py_setup_tstepc);
}

static FortranDataDef f2py_single_def[] = {
  {"scm",2,{{50000,14}},NPY_DOUBLE},
  {"spp",2,{{20,3}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_single(char *scm,char *spp) {
  int i_f2py=0;
  f2py_single_def[i_f2py++].data = scm;
  f2py_single_def[i_f2py++].data = spp;
}
extern void F_FUNC(f2pyinitsingle,F2PYINITSINGLE)(void(*)(char*,char*));
static void f2py_init_single(void) {
  F_FUNC(f2pyinitsingle,F2PYINITSINGLE)(f2py_setup_single);
}

static FortranDataDef f2py_binary_def[] = {
  {"bcm",2,{{50000,38}},NPY_DOUBLE},
  {"bpp",2,{{1000,43}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_binary(char *bcm,char *bpp) {
  int i_f2py=0;
  f2py_binary_def[i_f2py++].data = bcm;
  f2py_binary_def[i_f2py++].data = bpp;
}
extern void F_FUNC(f2pyinitbinary,F2PYINITBINARY)(void(*)(char*,char*));
static void f2py_init_binary(void) {
  F_FUNC(f2pyinitbinary,F2PYINITBINARY)(f2py_setup_binary);
}

static FortranDataDef f2py_checkstate_params_def[] = {
  {"dtp_state",1,{{15}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_checkstate_params(char *dtp_state) {
  int i_f2py=0;
  f2py_checkstate_params_def[i_f2py++].data = dtp_state;
}
extern void F_FUNC_US(f2pyinitcheckstate_params,F2PYINITCHECKSTATE_PARAMS)(void(*)(char*));
static void f2py_init_checkstate_params(void) {
  F_FUNC_US(f2pyinitcheckstate_params,F2PYINITCHECKSTATE_PARAMS)(f2py_setup_checkstate_params);
}

static FortranDataDef f2py_checkstate_array_def[] = {
  {"checkstate_array",2,{{15,123}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_checkstate_array(char *checkstate_array) {
  int i_f2py=0;
  f2py_checkstate_array_def[i_f2py++].data = checkstate_array;
}
extern void F_FUNC_US(f2pyinitcheckstate_array,F2PYINITCHECKSTATE_ARRAY)(void(*)(char*));
static void f2py_init_checkstate_array(void) {
  F_FUNC_US(f2pyinitcheckstate_array,F2PYINITCHECKSTATE_ARRAY)(f2py_setup_checkstate_array);
}

static FortranDataDef f2py_check_dtp_def[] = {
  {"check_dtp",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_check_dtp(char *check_dtp) {
  int i_f2py=0;
  f2py_check_dtp_def[i_f2py++].data = check_dtp;
}
extern void F_FUNC_US(f2pyinitcheck_dtp,F2PYINITCHECK_DTP)(void(*)(char*));
static void f2py_init_check_dtp(void) {
  F_FUNC_US(f2pyinitcheck_dtp,F2PYINITCHECK_DTP)(f2py_setup_check_dtp);
}

static FortranDataDef f2py_fall_def[] = {
  {"fallback",0,{{-1}},NPY_DOUBLE},
  {NULL}
};
static void f2py_setup_fall(char *fallback) {
  int i_f2py=0;
  f2py_fall_def[i_f2py++].data = fallback;
}
extern void F_FUNC(f2pyinitfall,F2PYINITFALL)(void(*)(char*));
static void f2py_init_fall(void) {
  F_FUNC(f2pyinitfall,F2PYINITFALL)(f2py_setup_fall);
}

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {
    {"evolv2",-1,{{-1}},0,(char *)F_FUNC(evolv2,EVOLV2),(f2py_init_func)f2py_rout_evolvbin_evolv2,doc_f2py_rout_evolvbin_evolv2},

/*eof routine_defs*/
    {NULL}
};

static PyMethodDef f2py_module_methods[] = {

    {NULL,NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "evolvbin",
    NULL,
    -1,
    f2py_module_methods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyMODINIT_FUNC PyInit_evolvbin(void) {
    int i;
    PyObject *m,*d, *s, *tmp;
    m = evolvbin_module = PyModule_Create(&moduledef);
    Py_SET_TYPE(&PyFortran_Type, &PyType_Type);
    import_array();
    if (PyErr_Occurred())
        {PyErr_SetString(PyExc_ImportError, "can't initialize module evolvbin (failed to import numpy)"); return m;}
    d = PyModule_GetDict(m);
    s = PyUnicode_FromString("1.23.4");
    PyDict_SetItemString(d, "__version__", s);
    Py_DECREF(s);
    s = PyUnicode_FromString(
        "This module 'evolvbin' is auto-generated with f2py (version:1.23.4).\nFunctions:\n"
"    bpp_index_out,bcm_index_out,kick_info_out = evolv2(kstar,mass,tb,ecc,z,tphysf,dtp,mass0,rad,lumin,massc,radc,menv,renv,ospin,b_0,bacc,tacc,epoch,tms,bhspin,tphys,zpars,bkick,kick_info)\n"
"COMMON blocks:\n""  /rand1/ idum1\n""  /rand2/ idum2,iy,ir(32)\n""  /types/ ktype(15,15)\n""  /flags/ tflag,ifflag,remnantflag,wdflag,bhflag,windflag,qcflag,eddlimflag,bhspinflag,aic,rejuvflag,htpmb,st_cr,st_tide,bdecayfac,grflag,bhms_coll_flag\n""  /mtvars/ don_lim,acc_lim,mbh_initial\n""  /ceflags/ ceflag,cekickflag,cemergeflag,cehestarflag,ussn\n""  /trackers/ pisn_track(2)\n""  /metvars/ zsun\n""  /windvars/ neta,bwind,hewind,beta,xi,acc2,epsnov,eddfac,gamma\n""  /cevars/ qcrit_array(16),alpha1,lambdaf\n""  /magvars/ bconst,ck\n""  /snvars/ natal_kick_array(2,5),sigma,sigmadiv,bhsigmafrac,polar_kick_angle,pisn,ecsn,ecsn_mlow,bhspinmag,mxns,rembar_massloss,kickflag\n""  /tidalvars/ fprimc_array(16)\n""  /mixvars/ rejuv_fac\n""  /cmcpass/ merger,id1_pass,id2_pass,using_cmc\n""  /points/ pts1,pts2,pts3\n""  /tstepc/ dmmax,drmax\n""  /single/ scm(50000,14),spp(20,3)\n""  /binary/ bcm(50000,38),bpp(1000,43)\n""  /checkstate_params/ dtp_state(15)\n""  /checkstate_array/ checkstate_array(15,123)\n""  /check_dtp/ check_dtp\n""  /fall/ fallback\n"".");
    PyDict_SetItemString(d, "__doc__", s);
    Py_DECREF(s);
    s = PyUnicode_FromString("1.23.4");
    PyDict_SetItemString(d, "__f2py_numpy_version__", s);
    Py_DECREF(s);
    evolvbin_error = PyErr_NewException ("evolvbin.error", NULL, NULL);
    /*
     * Store the error object inside the dict, so that it could get deallocated.
     * (in practice, this is a module, so it likely will not and cannot.)
     */
    PyDict_SetItemString(d, "_evolvbin_error", evolvbin_error);
    Py_DECREF(evolvbin_error);
    for(i=0;f2py_routine_defs[i].name!=NULL;i++) {
        tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
        PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
        Py_DECREF(tmp);
    }

/*eof initf2pywraphooks*/
/*eof initf90modhooks*/

  tmp = PyFortranObject_New(f2py_rand1_def,f2py_init_rand1);
  F2PyDict_SetItemString(d, "rand1", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_rand2_def,f2py_init_rand2);
  F2PyDict_SetItemString(d, "rand2", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_types_def,f2py_init_types);
  F2PyDict_SetItemString(d, "types", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_flags_def,f2py_init_flags);
  F2PyDict_SetItemString(d, "flags", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_mtvars_def,f2py_init_mtvars);
  F2PyDict_SetItemString(d, "mtvars", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_ceflags_def,f2py_init_ceflags);
  F2PyDict_SetItemString(d, "ceflags", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_trackers_def,f2py_init_trackers);
  F2PyDict_SetItemString(d, "trackers", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_metvars_def,f2py_init_metvars);
  F2PyDict_SetItemString(d, "metvars", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_windvars_def,f2py_init_windvars);
  F2PyDict_SetItemString(d, "windvars", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_cevars_def,f2py_init_cevars);
  F2PyDict_SetItemString(d, "cevars", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_magvars_def,f2py_init_magvars);
  F2PyDict_SetItemString(d, "magvars", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_snvars_def,f2py_init_snvars);
  F2PyDict_SetItemString(d, "snvars", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_tidalvars_def,f2py_init_tidalvars);
  F2PyDict_SetItemString(d, "tidalvars", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_mixvars_def,f2py_init_mixvars);
  F2PyDict_SetItemString(d, "mixvars", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_cmcpass_def,f2py_init_cmcpass);
  F2PyDict_SetItemString(d, "cmcpass", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_points_def,f2py_init_points);
  F2PyDict_SetItemString(d, "points", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_tstepc_def,f2py_init_tstepc);
  F2PyDict_SetItemString(d, "tstepc", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_single_def,f2py_init_single);
  F2PyDict_SetItemString(d, "single", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_binary_def,f2py_init_binary);
  F2PyDict_SetItemString(d, "binary", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_checkstate_params_def,f2py_init_checkstate_params);
  F2PyDict_SetItemString(d, "checkstate_params", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_checkstate_array_def,f2py_init_checkstate_array);
  F2PyDict_SetItemString(d, "checkstate_array", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_check_dtp_def,f2py_init_check_dtp);
  F2PyDict_SetItemString(d, "check_dtp", tmp);
  Py_DECREF(tmp);
  tmp = PyFortranObject_New(f2py_fall_def,f2py_init_fall);
  F2PyDict_SetItemString(d, "fall", tmp);
  Py_DECREF(tmp);
/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
    if (! PyErr_Occurred())
        on_exit(f2py_report_on_exit,(void*)"evolvbin");
#endif
    return m;
}
#ifdef __cplusplus
}
#endif
